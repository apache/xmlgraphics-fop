<?xml version="1.0" standalone="no"?>


<!-- Output Formats: Renderers -->
<document>
    <header>
        <title>Output</title>
        <subtitle>Notes about Output Formats: Renderers</subtitle>
        <authors>
            <person name="Keiron Liddle" email="keiron@aftexsw.com"/>
            <person name="Art Welch"/>
        </authors>
    </header>

    <body>
<s1 title="Output Formats">
    <p>
FOP supports a number of different output formats. This is achieved by
using different renderers that create the output.
    </p>
    <p>
Here we will explain some information for uses to be able to understand
what the renderers are doing and what difference there may be between
different renderers.
    </p>
<s2 title="Common Information">
    <p>
Each renderer is given an area tree to render to its output format.
The area tree is simply a representation of the pages and the placement
of text and graphical objects on those pages.
    </p>
    <p>
The renderer will be given each page as it is ready and an output stream
to write the data out. The renderer is responsible for managing the
output format and associated data and flow.
    </p>
    <p>
Fonts and Layout - some formats (eg. PDF and AWT) rely on different
font information. The fonts for these outputs have different sizes
for the same point size. This means that the layout can be quite
different for the same fo document.
    </p>
    <p>
DPI - This is an important issue when creating output for printing.
The dpi is used to convert measurements into points. For example 1in
= 2.54cm = 72 points. It is also used when determining the size of
images and the rendering of certain graphics in the output. Currently
FOP uses a value of 72dpi.
    </p>
    <p>
You may want to send your output directly to a printer. The Print
renderer uses the java api to print the document or you might be
able to send the output stream directly to a printer. If your printer
supports postscript you could send the postscript to the printer. If
you have a printer that supports PCL you could stream the PCL document
to your printer.
On Windows:
<source><![CDATA[fop ... -ps \\computername\printer or fop ... -pcl \\computername\printer]]></source>
On UNIX:
<source><![CDATA[proc = Runtime.getRuntime().exec("lp -d" + print_queue + " -o -dp -");
out = proc.getOutputStream();]]></source>
And give the OutputStream (out) to the PCLRenderer and it happily sends the
PCL to the AIX print queue.
    </p>
</s2>
<s2 title="PDF">
    <p>
PDF is the best supported output format. It is also the most accurate
with text and layout. This creates a PDF document that is streamed out
as each page is rendered. This means that the internal page index
information is stored near the end of the document.
The PDF version supported is 1.3 which is currently the most popular
version for Acrobat Reader (4.0), PDF versions are forwards/backwards
compatible.
    </p>
</s2>
<s2 title="PCL">
    <p>
This format is for the Hewlett-Packard PCL printers.
It should produce output as close to identical as possible to the
printed output of the PDFRenderer within the limitations of the
renderer, and output device.
    </p>
    <p>
The output created by the PCLRenderer is generic PCL 5 as documented
in the "HP PCL 5 Printer Language Technical Reference Manual" (copyright 1990).
This should allow any device fully supporting PCL 5 to be able to
print the output generated by the PCLRenderer.
    </p>
    <s3 title="Limitations">
      <ul>
        <li>Text or graphics outside the left or top of the printable area are not rendered properly. In general things that should print to the left of the printable area are shifted to the right so that they start at the left edge of the printable area and an error message is generated.</li>
        <li>The Helvetica and Times fonts are not well supported among PCL printers so Helvetica is mapped to Arial and Times is mapped to Times New. This is done in the PCLRenderer, no changes are required in the FO's. The metrics and appearance for Helvetica/Arial and Times/Times New are nearly identical, so this has not been a problem so far.</li>
        <li>Only the original fonts built into FOP are supported.</li>
        <li>For the non-symbol fonts, the ISO 8859/1 symbol set is used (PCL set "0N").</li>
        <li>Multibyte characters are not supported.</li>
        <li>SVG support is limited. Currently only lines, rectangles (may be rounded), circles, ellipses, text, simple paths, and images are supported. Colors are supported (dithered black and white) but not gradients.</li>
        <li>Images print black and white only (not dithered). When the renderer prints a color image it uses a threshold value, colors above the threshold are printed as white and below are black. If you need to print a non-monochrome image you should dither it first.</li>
        <li>Image scaling is accomplished by modifying the effective resolution of the image data. The available resolutions are 75, 100, 150, 300, and 600 DPI.</li>
        <li>Color printing is not supported. Colors are rendered by mapping the color intensity to one of the PCL fill shades (from white to black in 9 steps).</li>
        <li>SVG clipping is not supported.</li>
      </ul>
    </s3>

    <s3 title="Additional Features">
      <p>There are some special features that are controlled by some public variables on the PCLRenderer class.</p>

      <dl>
        <dt>orientation</dt>
        <dd><p>The logical page orientation is controlled by the public orientation variable. Legal values are:</p>
          <ul>
            <li>0 Portrait</li>
            <li>1 Landscape</li>
            <li>2 Reverse Portrait</li>
            <li>3 Reverse Landscape</li>
          </ul>
        </dd>
        <dt>curdiv, paperheight</dt>
        <dd>The curdiv and paperheight variables allow multiple virtual pages to be printed on a piece of paper. This allows a standard laser printer to use perforated paper where every perforation will represent an individual page. The paperheight sets the height of a piece of paper in decipoints. This will be divided by the page.getHeight() to determine the number of equal sized divisions (pages) that will fit on the paper. The curdiv variable may be read/written to get/set the current division on the page (to set the starting division and read the ending division for multiple invocations).</dd>
        <dt>topmargin, leftmargin</dt>
        <dd>The topmargin and leftmargin may be used to increase the top and left margins for printing.</dd>
      </dl>
    </s3>
</s2>
<s2 title="PostScript">
    <p>
The PostScript renderer is still in its early stages and therefore still
missing some features. It provides good support for most text and layout. 
Images and SVG are not fully supported, yet. Currently, the PostScript
renderer generates PostScript Level 3 with most DSC comments. Actually, 
the only Level 3 feature used is FlateDecode, everthing else is Level 2.
    </p>
    <s3 title="Limitations">
      <ul>
        <li>Images and SVG may not be display correctly. SVG support is far from being complete. No image transparency is available.</li>
        <li>Character spacing may be wrong.</li>
        <li>No font embedding is supported.</li>
        <li>Multibyte characters are not supported.</li>
        <li>PPD support is still missing.</li>
        <li>The renderer is not yet configurable.</li>
      </ul>
    </s3>
</s2>
<s2 title="RTF">
    <p>
This is currently not integrated with FOP but it will soon.
This will create an rtf (rich text format) document that will
attempt to contain as much information from the fo document as
possible.
    </p>
</s2>
<s2 title="SVG">
    <p>
This format creates an SVG document that has links between the pages.
This is primarily for slides and creating svg images of pages.
Large documents will create SVG files that are far too large for
and SVG viewer to handle. Since fo documents usually have text the
SVG document will have a large number of text elements.
The font information for the text is obtained from the jvm in the
same way as the AWT viewer, if the svg is view where the fonts are
different, such as another platform, then the page will appear wrong.
    </p>
</s2>
<s2 title="XML">
    <p>
This is for testing and verification. The XML created is simply
a representation of the internal area tree put into XML. It does
not perform any other purpose.
    </p>
</s2>
<s2 title="Print">
    <p>
It is possible to directly print the document from the command line.
This is done with the same code that renders to the AWT renderer.
    </p>
</s2>
<s2 title="AWT">
    <p>
The AWT viewer shows a window with the pages displayed inside a
java graphic. It displays one page at a time.
The fonts used for the formatting and viewing depend on the fonts
available to your JRE.
    </p>
</s2>
<s2 title="MIF">
    <p>
This format is the Maker Interchange Format which is used by
Adobe Framemaker. This is currently not fully implemented.
    </p>
</s2>
<s2 title="TXT">
    <p>
Text as you could imagine does not work very well. It is an output format
that you should expect bad results. The main purpose of this is to get
a quick and dirty view of the document and the text inside it.
    </p>
    <p>
The TXTRenderer is a FOP renderer that produces plain ASCII text output
that attempts to match the output of the PDFRenderer as closely as
possible. This was originally developed to accommodate an archive system
that could only accept plain text files. Of course when limited to plain
fixed pitch text the output does not always look very good.
    </p>
    <p>
The TXTRenderer works with a fixed size page buffer. The size of this
buffer is controlled with the textCPI and textLPI public variables.
The textCPI is the effective horizontal characters per inch to use.
The textLPI is the vertical lines per inch to use. From these values
and the page width and height the size of the buffer is calculated.
The formatting objects to be rendered are then mapped to this grid.
Graphic elements (lines, borders, etc) are assigned a lower priority
than text, so text will overwrite any graphic element representations.
    </p>
</s2>

</s1>
    </body>
</document>


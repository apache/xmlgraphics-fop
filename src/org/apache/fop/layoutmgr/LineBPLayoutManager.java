/*
 * $Id$
 * Copyright (C) 2001 The Apache Software Foundation. All rights reserved.
 * For details on use and redistribution please refer to the
 * LICENSE file included with these sources.
 */

package org.apache.fop.layoutmgr;


import org.apache.fop.fo.FObj;
import org.apache.fop.fo.TextInfo;
import org.apache.fop.fo.PropertyManager;
import org.apache.fop.layout.MarginProps;
import org.apache.fop.traits.BlockProps;
import org.apache.fop.area.Area;
import org.apache.fop.area.LineArea;
import org.apache.fop.area.MinOptMax;
import org.apache.fop.area.inline.InlineArea;
import org.apache.fop.fo.properties.TextAlign;

import org.apache.fop.area.inline.Word;
import org.apache.fop.area.inline.Space;
import org.apache.fop.area.inline.Character;

import java.util.ListIterator;
import java.util.List;
import java.util.Vector;
import java.util.ArrayList;


/**
 * BPLayoutManager for lines. It builds one or more lines containing
 * inline areas generated by its sub layout managers.
 */
public class LineBPLayoutManager extends LineLayoutManager {

    /**
     * Private class to store information about inline breaks.
     * Each value holds the start and end indexes into a List of
     * inline break positions.
     */
    private static class LineBreakPosition implements BreakPoss.Position {
        int m_iPos;

        LineBreakPosition(int iBreakIndex) {
            m_iPos = iBreakIndex;
        }
    }

    private BPLayoutManager m_curChildLM=null;
    private ListIterator m_childLMiter;

    private LineArea m_lineArea; // LineArea currently being filled

    /** Break positions returned by inline content. */
    private Vector m_vecInlineBreaks = new Vector(100);

    private SpaceSpecifier m_pendingSpace;
    private BreakPoss m_prevBP = null; // Last confirmed break position
    private boolean m_bJustify = false; // True if fo:block text-align=JUSTIFY
    private int m_iTextIndent = 0;
    private int m_iIndents = 0;


    public LineBPLayoutManager(FObj fobj, List lms, int lh, int l, int f) {
	super(fobj, lms, lh, l, f);
	m_childLMiter = lms.listIterator();
	initProperties();
    }

    protected void initProperties(PropertyManager propMgr) {
	super.initProperties(propMgr);
	System.err.println("LineBPLayoutManager.initProperties called");
        MarginProps marginProps = propMgr.getMarginProps();
        m_iIndents = marginProps.startIndent + marginProps.endIndent;
	BlockProps blockProps = propMgr.getBlockProps();
	m_bJustify = (blockProps.textAlign == TextAlign.JUSTIFY);
	m_iTextIndent = blockProps.firstIndent;
    }
    

    /**
     * Return next child LayoutManager or null if there is none.
     * Note: child must implement BPLayoutManager! If it doesn't, skip it
     * and print a warning.
     * The list of all child layout managers is in lmList (in superclass!)
     */
    private BPLayoutManager getChildLM() {
	if (m_curChildLM != null && !m_curChildLM.isFinished()) {
	    return m_curChildLM;
	}
	while (m_childLMiter.hasNext()) {
	    Object obj = m_childLMiter.next();
	    if (obj instanceof BPLayoutManager) {
		m_curChildLM = (BPLayoutManager)obj;
		m_curChildLM.setParentLM(this);
		return m_curChildLM;
	    }
	    else {
		m_childLMiter.remove();
		System.err.println("WARNING: child of LineLPLayoutManager not a BPLayoutManager: " + obj.getClass().getName());
	    }
	}
	return null;
    }

    /**
     * Reset the layoutmanager "iterator" so that it will start
     * with the passed bplm on the next call to getChildLM.
     * @param bplm Reset iterator to this LayoutManager.
     */
    private void resetChildLM(BPLayoutManager bplm) {
	if (bplm == null) return;
	while (m_curChildLM != bplm && m_childLMiter.hasPrevious()) {
	    m_curChildLM = (BPLayoutManager)m_childLMiter.previous();
	}
	if ( m_curChildLM.isFinished()) {
	    m_curChildLM.setFinished(false);
	}
    }



    /**
     * Call child layout managers to generate content as long as they
     * generate inline areas. If a block-level generating LM is found,
     * finish any line being filled and return to the parent LM.
     */
    public BreakPoss getNextBreakPoss(LayoutContext context,
				      BreakPoss.Position prevLineBP) {
        // Get a break from currently active child LM
        // Set up constraints for inline level managers

        if ((context.flags & LayoutContext.CHECK_REF_AREA) != 0) {
            /* Return a BreakPoss indicating that higher level LM
	     * (page) should check reference area and possibly
	     * create a new one.
	     */
	    return new BreakPoss(this, null, BreakPoss.NEED_IPD);
        }

	BPLayoutManager prevLM = null; // previous active LM
	BPLayoutManager curLM ;        // currently active LM
        BreakPoss bp=null;           // proposed BreakPoss

	// IPD remaining in line
        MinOptMax availIPD = context.stackLimit;

	// IPD of any unbreakable finished FO content
        MinOptMax pendingIPD = null;

	// QUESTION: maybe LayoutContext holds the Properties which
	// come from block-level?

	LayoutContext inlineLC = new LayoutContext(context);
	inlineLC.setPendingSpace(new SpaceSpecifier(true));

        while ((curLM = getChildLM()) != null) {
	    // INITIALIZE FLAGS FOR CALL TO CHILD LM
	    boolean bFirstBPforLM = (prevLM != curLM);
	    if (bFirstBPforLM) {
		prevLM = curLM;
		inlineLC.setFlags(LayoutContext.START_AREA);
		if (bp != null) {
		    inlineLC.setPendingSpace(bp.getTrailingSpace());
		}
	    }
	    else {
		inlineLC.unsetFlags(LayoutContext.START_AREA);
		inlineLC.setPendingSpace(null);
	    }
            /* If first BP in this line but line is not first in this
             * LM and previous possible linebreak was not forced (LINEFEED),
             * then set the SUPPRESS_LEADING_SPACE flag.
             */
            if (bp == null && !m_vecInlineBreaks.isEmpty() &&
                ((BreakPoss)m_vecInlineBreaks.lastElement()).
		                            isForcedBreak()==false) {
		inlineLC.setFlags(LayoutContext.SUPPRESS_LEADING_SPACE);
            }
            else {
                inlineLC.unsetFlags(LayoutContext.SUPPRESS_LEADING_SPACE);
            }
	    // GET NEXT POSSIBLE BREAK FROM CHILD LM
            if ((bp = curLM.getNextBreakPoss(inlineLC,
					     (m_prevBP !=null ?
					      m_prevBP.getPosition() :
					      null))) != null) {
		// check if this bp fits in line
		MinOptMax bpDim = (MinOptMax)bp.getStackingSize().clone();
		/* If first BP for this LM (in this call)
		 * add any leading space.
		 */
		if (bFirstBPforLM) {
		    if (pendingIPD != null) {
			bpDim.add(pendingIPD);
		    }
		    bpDim.add(bp.resolveLeadingSpace());
		}
		boolean bBreakOK = couldEndLine(bp);
		if (bBreakOK) {
		    /* Add any non-conditional trailing space. */
		    bpDim.add(bp.resolveTrailingSpace(true));
		}
		// Check if proposed area would fit in line
		if (bpDim.max < availIPD.min) {
		    // Break fits buts is short
		    if (bBreakOK) {
			if (pendingIPD != null) {
			    availIPD.subtract(pendingIPD);
			    // Subtract space-start for this area, since
			    // we know at least part of it fits.
			    availIPD.subtract(bp.getLeadingSpace().
					      resolve(false));
			    pendingIPD = null;
			    // Add all pending BP list members to BP list
			}
			m_prevBP = bp; // Save reference to this BP
			m_vecInlineBreaks.add(bp);
			// Handle end of this LM's areas
			if (bp.isLastArea()) {
			    /* NOTE: this doesn't include space-end since
			     * it may combine with space-start on the
			     * following FO's first area.
			     */
			    availIPD.subtract(bp.getStackingSize());
			}
		    }
		    else { 
			/* Can't end line here, so mark size pending.
			 * This includes any previosly pending size,
			 * already calculated above.
			 */
			pendingIPD = bpDim;
			// Add BP to the pending list
		    }
		}
		else if (bpDim.min > availIPD.max) {
		    // This break position doesn't fit
		    if (m_bJustify || m_prevBP == null) {
			// try to find a hyphenation point in the word
			// which spans the queued breaks and the proposed bp
			// Even if not justified, we must try to hyphenate if
			// there is no breakpoint at all up to this point!
			do {
			    bp = findHyphenPoss(m_prevBP, bp);
			} while (bp != null &&
				 (bp.getStackingSize().min > availIPD.max));
			if (bp == null) {
			    // Couldn't find a hyphenation point. The line
			    // will be "short".
			}
			else {
			    m_prevBP = bp;
			}
			// Handle pendingIPD if any. The hyphenation point
			// may be within the "pending" content or after it.
                        /* Make sure child LM are updated concerning the actual
                         * hyphenation BreakPoss for their next call!
                         */
		    }
		    /* If we are not in justified text, we can end the line at
		     * prevBP.
		     */
		    break;
		}
		else {
		    /* This is a possible line BP (line could be filled)
		     * bpDim.max >= availIPD.min
		     * Keep this as a possible break, depending on "cost".
		     * We will choose lowest cost. Cost depends on stretch
		     * (ie, bpDim.opt closes to availIPD.opt), keeps
		     * and hyphenation.
		     */
		    m_prevBP = bp;
		    break; //???
		}
	    } // end of getNextBreakPoss!=null on current child LM
	    else {
		/* What if the childLM returns null?
		 * No further break possibility in current sequence of
		 * inline LM. Previous break or end of area will be the
		 * ending for the current line.
		 * Otherwise we have filled the current line.
		 */
	    }
	} // end of while on child LM
	if ((curLM = getChildLM())== null) {
	    // No more content to layout!
	    setFinished(true);
	}
	// Backup layoutmanager if necessary
	resetChildLM(m_prevBP.getLayoutManager());
        return makeLineBreak(m_prevBP);
    }

    /**
     * Return whether we could end the line at the proposed Position.
     * TODO: take keeps into account and distinguish the cost of a
     * the break-completely forbidden or some non-0 cost.
     * QUESTION: do we need to pass the current LineLM or childLM
     * LayoutContext?
     */
    private boolean couldEndLine(BreakPoss bp) {
	if (bp.canBreakAfter()) {
	    return true; // no keep, ends on break char
	}
	else if (bp.isSuppressible()) {
	    // NOTE: except at end of content for this LM!!
	    // Never break after only space chars or any other sequence
	    // of areas which would be suppressed at the end of the line.
	    return false; 
	}
	else {
	    // See if could break before next area
	    LayoutContext lc=new LayoutContext();
	    BPLayoutManager nextLM = getChildLM();
	    return (nextLM == null || 
		    nextLM.canBreakBefore(lc));
	}
    }


    private BreakPoss findHyphenPoss(BreakPoss prevBP, BreakPoss newBP) {
	return null;
    }

    private BreakPoss makeLineBreak(BreakPoss inlineBP) {
        // make a new BP
        BreakPoss curLineBP =
            new BreakPoss(this,
			  new LineBreakPosition(m_vecInlineBreaks.size()-1));

	/* FIX ME!! 
	 * Need to calculate line height based on all inline BP info
	 * for this line not just the current inlineBP!
	 */
	curLineBP.setFlag(BreakPoss.ISLAST, isFinished());
	curLineBP.setStackingSize(inlineBP.getNonStackingSize());
        return curLineBP;
    }


    // Generate and add areas to parent area
    // Set size etc
    public void addAreas(PositionIterator parentIter) {
	BPLayoutManager childLM ;
	int iStartPos = 0;
	while  (parentIter.hasNext()) {
	    LineBreakPosition lbp  = (LineBreakPosition)parentIter.next();
	    System.err.println("lbp.endpos=" + lbp.m_iPos);
	    m_lineArea = new LineArea();
	    // Add the inline areas to lineArea
	    PositionIterator inlinePosIter =
		new BreakPossPosIter(m_vecInlineBreaks,
				     iStartPos, lbp.m_iPos+1);
	    iStartPos = lbp.m_iPos+1;
	    while  (inlinePosIter.hasNext() && 
		    (childLM = inlinePosIter.getNextChildLM())!= null) {
		childLM.addAreas(inlinePosIter);
	    }
	    verticalAlign(m_lineArea);
	    parentLM.addChild(m_lineArea);
	}
	m_lineArea = null;
    }

    public boolean addChild(Area childArea) {
	// Make sure childArea is inline area
	if (childArea instanceof InlineArea) {
	    m_lineArea.addInlineArea((InlineArea)childArea);
	}
	return false;
    }

    // NOTE: PATCHED FOR NOW TO ADD BreakPoss stuff to Kerion's changes
    public boolean generateAreas() {
	// Make break positions and return lines!
	// Set up a LayoutContext
	int ipd = 0;
	BreakPoss bp;
	Vector vecBreakPoss = new Vector(20);

	LayoutContext childLC = new LayoutContext();
	// Force area creation on first call
	// NOTE: normally not necessary
	childLC.flags |= LayoutContext.CHECK_REF_AREA;

	while (!isFinished()) {
	    if ((bp = getNextBreakPoss(childLC, null)) != null) {
		if (bp.checkIPD()) {
		    // Need IPD in order to layout lines!
		    // This is supposed to bubble up to PageLM to
		    // make the necessary flow reference area, depending
		    // on span and break-before flags set as the BreakPoss
		    // makes its way back up the call stack.
		    // Fake it for now!
		    parentLM.getParentArea(null);
		    ipd = parentLM.getContentIPD();
		    childLC.flags &= ~LayoutContext.CHECK_REF_AREA;
		    childLC.stackLimit = new MinOptMax(ipd - m_iIndents -
						       m_iTextIndent);
		}
		else {
		    vecBreakPoss.add(bp);
		    // Reset stackLimit for non-first lines
		    childLC.stackLimit = new MinOptMax(ipd - m_iIndents);
		}
	    }
        }
	addAreas(new BreakPossPosIter(vecBreakPoss, 0, vecBreakPoss.size()));
        return false;
    }


}


/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* $Id$ */

package org.apache.fop.layoutmgr.inline;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.fop.area.Area;
import org.apache.fop.area.LineArea;
import org.apache.fop.area.Trait;
import org.apache.fop.area.inline.InlineArea;
import org.apache.fop.datatypes.Length;
import org.apache.fop.datatypes.Numeric;
import org.apache.fop.fo.flow.Block;
import org.apache.fop.fo.properties.CommonHyphenation;
import org.apache.fop.fonts.Font;
import org.apache.fop.fonts.FontInfo;
import org.apache.fop.fonts.FontTriplet;
import org.apache.fop.hyphenation.Hyphenation;
import org.apache.fop.hyphenation.Hyphenator;
import org.apache.fop.layoutmgr.BlockLevelLayoutManager;
import org.apache.fop.layoutmgr.BreakElement;
import org.apache.fop.layoutmgr.ElementListObserver;
import org.apache.fop.layoutmgr.InlineKnuthSequence;
import org.apache.fop.layoutmgr.KnuthBlockBox;
import org.apache.fop.layoutmgr.KnuthBox;
import org.apache.fop.layoutmgr.KnuthElement;
import org.apache.fop.layoutmgr.KnuthGlue;
import org.apache.fop.layoutmgr.KnuthPenalty;
import org.apache.fop.layoutmgr.KnuthPossPosIter;
import org.apache.fop.layoutmgr.KnuthSequence;
import org.apache.fop.layoutmgr.LayoutContext;
import org.apache.fop.layoutmgr.LayoutManager;
import org.apache.fop.layoutmgr.LeafPosition;
import org.apache.fop.layoutmgr.LineBreakingAlgorithm;
import org.apache.fop.layoutmgr.ListElement;
import org.apache.fop.layoutmgr.NonLeafPosition;
import org.apache.fop.layoutmgr.ParagraphListElement;
import org.apache.fop.layoutmgr.Position;
import org.apache.fop.layoutmgr.PositionIterator;
import org.apache.fop.layoutmgr.SpaceSpecifier;
import org.apache.fop.traits.MinOptMax;

/**
 * LayoutManager for lines. It builds one or more lines containing
 * inline areas generated by its sub layout managers.
 * A break is found for each line which may contain one of more
 * breaks from the child layout managers.
 * Once a break is found then it is return for the parent layout
 * manager to handle.
 * When the areas are being added to the page this manager
 * creates a line area to contain the inline areas added by the
 * child layout managers.
 */
/**
 * 
 */
public class LineLayoutManager extends InlineStackingLayoutManager 
                               implements BlockLevelLayoutManager {

    /**
     * logging instance
     */
    private static Log log = LogFactory.getLog(LineLayoutManager.class);

    private Block fobj;
    private boolean isFirstInBlock;
    
    /** {@inheritDoc} */
    public void initialize() {
        textAlignment = fobj.getTextAlign();
        textAlignmentLast = fobj.getTextAlignLast();
        textIndent = fobj.getTextIndent();
        lastLineEndIndent = fobj.getLastLineEndIndent();
        hyphenationProperties = fobj.getCommonHyphenation();
        hyphenationLadderCount = fobj.getHyphenationLadderCount();
        wrapOption = fobj.getWrapOption();
        whiteSpaceTreament = fobj.getWhitespaceTreatment();
        //
        effectiveAlignment = getEffectiveAlignment(textAlignment, textAlignmentLast);
        isFirstInBlock = (this == getParent().getChildLMs().get(0));
    }

    private int getEffectiveAlignment(int alignment, int alignmentLast) {
        if (textAlignment != EN_JUSTIFY && textAlignmentLast == EN_JUSTIFY) {
            return 0;
        } else {
            return textAlignment;
        }
    }
    
    /**
     * Private class to store information about inline breaks.
     * Each value holds the start and end indexes into a List of
     * inline break positions.
     */
    public static class LineBreakPosition extends LeafPosition {
        private int iParIndex; // index of the Paragraph this Position refers to
        private int iStartIndex; //index of the first element this Position refers to
        private int availableShrink;
        private int availableStretch;
        private int difference;
        private double dAdjust; // Percentage to adjust (stretch or shrink)
        private double ipdAdjust; // Percentage to adjust (stretch or shrink)
        private int startIndent;
        private int lineHeight;
        private int lineWidth;
        private int spaceBefore;
        private int spaceAfter;
        private int baseline;

        public LineBreakPosition(LayoutManager lm, int index, int iStartIndex, int iBreakIndex,
                          int shrink, int stretch, int diff,
                          double ipdA, double adjust, int ind,
                          int lh, int lw, int sb, int sa, int bl) {
            super(lm, iBreakIndex);
            availableShrink = shrink;
            availableStretch = stretch;
            difference = diff;
            iParIndex = index;
            this.iStartIndex = iStartIndex;
            ipdAdjust = ipdA;
            dAdjust = adjust;
            startIndent = ind;
            lineHeight = lh;
            lineWidth = lw;
            spaceBefore = sb;
            spaceAfter = sa;
            baseline = bl;
        }
        
    }


    private int textAlignment = EN_JUSTIFY;
    private int textAlignmentLast;
    private int effectiveAlignment;
    private Length textIndent;
    private Length lastLineEndIndent;
    public CommonHyphenation hyphenationProperties;
    private Numeric hyphenationLadderCount;
    private int wrapOption = EN_WRAP;
    private int whiteSpaceTreament;
    //private LayoutProps layoutProps;
    private LayoutContext context;

    private Length lineHeight;
    private int lead;
    private int follow;
    private AlignmentContext alignmentContext = null;

    private List knuthParagraphs = null;
    private int iReturnedLBP = 0;

    //     parameters of Knuth's algorithm:
    // penalty value for flagged penalties
    private int flaggedPenalty = 50;

    private LineLayoutPossibilities lineLayouts;
    private int iLineWidth = 0;

    /**
     * this constant is used to create elements when text-align is center:
     * every TextLM descendant of LineLM must use the same value, 
     * otherwise the line breaking algorithm does not find the right
     * break point
     */
    public static final int DEFAULT_SPACE_WIDTH = 3336;


    /**
     * This class is used to remember
     * which was the first element in the paragraph
     * returned by each LM.
     */
    private class Update {
        private InlineLevelLayoutManager inlineLM;
        private int iFirstIndex;

        public Update(InlineLevelLayoutManager lm, int index) {
            inlineLM = lm;
            iFirstIndex = index;
        }
    }
    
    public LineBreakPosition makeLineBreakPosition(KnuthParagraph par,
                                                    int firstElementIndex,
                                                    int lastElementIndex,
                                                    int availableShrink, 
                                                    int availableStretch, 
                                                    int difference,
                                                    double ratio,
                                                    int indent) {
        // line height calculation - spaceBefore may differ from spaceAfter
        // by 1mpt due to rounding
        int spaceBefore = (lineHeight.getValue(this) - lead - follow) / 2;
        int spaceAfter = lineHeight.getValue(this) - lead - follow - spaceBefore;
        // height before the main baseline
        int lineLead = lead;
        // maximum follow 
        int lineFollow = follow;
        // true if this line contains only zero-height, auxiliary boxes
        // and the actual line width is 0; in this case, the line "collapses"
        // i.e. the line area will have bpd = 0
        boolean bZeroHeightLine = (difference == iLineWidth);

        // if line-stacking-strategy is "font-height", the line height
        // is not affected by its content
        if (fobj.getLineStackingStrategy() != EN_FONT_HEIGHT) {
            ListIterator inlineIterator
                = par.listIterator(firstElementIndex);
            AlignmentContext lastAC = null;
            int maxIgnoredHeight = 0; // See spec 7.13
            for (int j = firstElementIndex;
                 j <= lastElementIndex;
                 j++) {
                KnuthElement element = (KnuthElement) inlineIterator.next();
                if (element instanceof KnuthInlineBox ) {
                    AlignmentContext ac = ((KnuthInlineBox) element).getAlignmentContext();
                    if (ac != null && lastAC != ac) {
                        if (!ac.usesInitialBaselineTable()
                            || ac.getAlignmentBaselineIdentifier() != EN_BEFORE_EDGE
                               && ac.getAlignmentBaselineIdentifier() != EN_AFTER_EDGE) {
                            if (fobj.getLineHeightShiftAdjustment() == EN_CONSIDER_SHIFTS
                                || ac.getBaselineShiftValue() == 0) {
                                int alignmentOffset = ac.getTotalAlignmentBaselineOffset();
                                if (alignmentOffset + ac.getAltitude() > lineLead) {
                                    lineLead = alignmentOffset + ac.getAltitude();
                                }
                                if (ac.getDepth() - alignmentOffset > lineFollow)  {
                                    lineFollow = ac.getDepth() - alignmentOffset;
                                }
                            }
                        } else {
                            if (ac.getHeight() > maxIgnoredHeight) {
                                maxIgnoredHeight = ac.getHeight();
                            }
                        }
                        lastAC = ac;
                    }
                    if (bZeroHeightLine
                        && (!element.isAuxiliary() || ac != null && ac.getHeight() > 0)) {
                        bZeroHeightLine = false;
                    }
                }
            }

            if (lineFollow < maxIgnoredHeight - lineLead) {
                lineFollow = maxIgnoredHeight - lineLead;
            }
        }

        constantLineHeight = lineLead + lineFollow;

        if (bZeroHeightLine) {
            return new LineBreakPosition(this,
                                         knuthParagraphs.indexOf(par),
                                         firstElementIndex, lastElementIndex,
                                         availableShrink, availableStretch,
                                         difference, ratio, 0, indent,
                                         0, iLineWidth, 0, 0, 0);
        } else {
            return new LineBreakPosition(this,
                                         knuthParagraphs.indexOf(par),
                                         firstElementIndex, lastElementIndex,
                                         availableShrink, availableStretch,
                                         difference, ratio, 0, indent,
                                         lineLead + lineFollow, 
                                         iLineWidth, spaceBefore, spaceAfter,
                                         lineLead);
        }
    }

    private int constantLineHeight = 12000;
      

    /**
     * Create a new Line Layout Manager.
     * This is used by the block layout manager to create
     * line managers for handling inline areas flowing into line areas.
     * @param block the block formatting object
     * @param lh the default line height
     * @param l the default lead, from top to baseline
     * @param f the default follow, from baseline to bottom
     */
    public LineLayoutManager(Block block, Length lh, int l, int f) {
        super(block);
        fobj = block;
        // the child FObj are owned by the parent BlockLM
        // this LM has all its childLMs preloaded
        fobjIter = null;
        lineHeight = lh;
        lead = l;
        follow = f;
    }

    /** {@inheritDoc} */
    public LinkedList getNextKnuthElements(LayoutContext context, int alignment) {
        this.context = context;
        FontInfo fi = fobj.getFOEventHandler().getFontInfo();
        FontTriplet[] fontkeys = fobj.getCommonFont().getFontState(fi);
        Font fs = fi.getFontInstance(fontkeys[0], fobj.getCommonFont().fontSize.getValue(this));
        alignmentContext
          = new AlignmentContext(fs, lineHeight.getValue(this), context.getWritingMode());
        context.setAlignmentContext(alignmentContext);
        // Get a break from currently active child LM
        // Set up constraints for inline level managers

        // IPD remaining in line
        // TODO availIPD.opt == iLineWidth

        clearPrevIPD();

        //PHASE 1: Create Knuth elements
        if (knuthParagraphs == null) {
            // it's the first time this method is called
            knuthParagraphs = new ArrayList();

            // here starts Knuth's algorithm
            collectInlineKnuthElements();
        } else {
            // this method has been called before
            // all line breaks are already calculated
        }

        // return finished when there's no content
        if (knuthParagraphs.size() == 0) {
            setFinished(true);
            return null;
        }

        setFinished(true);
        return postProcessSequences();
    }

    /**
     * Creates the element list in BP direction.
     * @return the newly built element list
     */
    private LinkedList postProcessSequences() {
    
        LinkedList returnList = new LinkedList();
        
        for (int p = 0; p < knuthParagraphs.size(); p++) {
            // null penalty between paragraphs
            if (p > 0 && !((BlockLevelLayoutManager) parentLM).mustKeepTogether()) {
                returnList.add(new BreakElement(new Position(this), 0, context));
            }
            KnuthSequence seq = (KnuthSequence) knuthParagraphs.get(p);
            if (!seq.isInlineSequence()) {
                ListIterator listIter = seq.listIterator();
                while (listIter.hasNext()) {
                    ListElement elt = (ListElement) listIter.next();
                    if (elt.getLayoutManager() != this) {
                        elt.setPosition(notifyPos(new NonLeafPosition(this,
                                elt.getPosition())));
                    }
                }
                // unwrap the (unnecessary) block sequence
                returnList.addAll(seq); 
            } else if (seq.isInlineSequence()) {
                Position returnPosition = new LeafPosition(this, p);
                ListElement elt = new ParagraphListElement((KnuthParagraph) seq, returnPosition);
                returnList.add(elt);
            }
        }
        
        return returnList;
    }

    /**
     * Phase 1 of Knuth algorithm: Collect all inline Knuth elements before determining line breaks.
     * @param context the LayoutContext
     */
    private void collectInlineKnuthElements() {
        LayoutContext inlineLC = new LayoutContext(context);
        
        InlineLevelLayoutManager curLM;
        LinkedList returnedList = null;
        // TODO this is the same as availIPD.opt
        iLineWidth = context.getStackLimit().opt;
            
        // convert all the text in a sequence of paragraphs made
        // of KnuthBox, KnuthGlue and KnuthPenalty objects
        boolean bPrevWasKnuthBox = false;
        
        StringBuffer trace = new StringBuffer("LineLM:");
        
        KnuthParagraph lastPar = null;
        
        while ((curLM = (InlineLevelLayoutManager) getChildLM()) != null) {
            returnedList = curLM.getNextKnuthElements(inlineLC, effectiveAlignment);
            if (returnedList == null
                    || returnedList.size() == 0) {
                /* curLM.getNextKnuthElements() returned null or an empty list;
                 * this can happen if there is nothing more to layout,
                 * so just iterate once more to see if there are other children */
                continue;
            }
            
            if (lastPar != null) {
                KnuthSequence firstSeq = (KnuthSequence) returnedList.getFirst();
                
                // finish last paragraph before a new block sequence
                if (!firstSeq.isInlineSequence()) {
                    if (lastPar.endSequence() != null) {
                        knuthParagraphs.add(lastPar);
                    }
                    ElementListObserver.observe(lastPar, "line", null);
                    lastPar = null;
                    if (log.isTraceEnabled()) {
                        trace.append(" ]");
                    }
                    bPrevWasKnuthBox = false;
                }
                
                // does the first element of the first paragraph add to an existing word?
                if (lastPar != null) {
                    KnuthElement thisElement;
                    thisElement = (KnuthElement) firstSeq.get(0);
                    if (thisElement.isBox() && !thisElement.isAuxiliary()
                            && bPrevWasKnuthBox) {
                        lastPar.addALetterSpace();
                    }
                }
            }
            
            // loop over the KnuthSequences (and single KnuthElements) in returnedList
            ListIterator iter = returnedList.listIterator();
            while (iter.hasNext()) {
                KnuthSequence sequence = (KnuthSequence) iter.next();
                // the sequence contains inline Knuth elements
                if (sequence.isInlineSequence()) {
                    // look at the last element 
                    ListElement lastElement = sequence.getLast();
                    if (lastElement == null) {
                        throw new NullPointerException(
                        "Sequence was empty! lastElement is null");
                    }
                    bPrevWasKnuthBox = lastElement.isBox() 
                                        && !((KnuthElement) lastElement).isAuxiliary() 
                                        && ((KnuthElement) lastElement).getW() != 0;
                    
                    // if last paragraph is open, add the new elements to the paragraph
                    // else this is the last paragraph
                    if (lastPar == null) {
                        int textIndentValue;
                        textIndentValue = (isFirstInBlock && knuthParagraphs.size() == 0
                                ? textIndent.getValue(this) : 0);
                        lastPar = new KnuthParagraph(textAlignment, textAlignmentLast, 
                                                     textIndentValue, lastLineEndIndent.getValue(this),
                                                     hyphenationLadderCount.getEnum() == EN_NO_LIMIT
                                                     ? 0 : hyphenationLadderCount.getValue(), this);
                        lastPar.startParagraph(iLineWidth);
                        if (log.isTraceEnabled()) {
                            trace.append(" [");
                        }
                    } else {
                        if (log.isTraceEnabled()) {
                            trace.append(" +");
                        }
                    }
                    lastPar.addSequence((InlineKnuthSequence) sequence);
                    if (log.isTraceEnabled()) {
                        trace.append(" I");
                    }
                    
                    if (lastPar.isClosed()) {
                        knuthParagraphs.add(lastPar);
                        ElementListObserver.observe(lastPar, "line", null);
                        lastPar = null;
                        if (log.isTraceEnabled()) {
                            trace.append(" ]");
                        }
                        bPrevWasKnuthBox = false;
                    }
                } else { // the sequence is a block sequence
                    // the positions will be wrapped with this LM in postProcessLineBreaks
                    knuthParagraphs.add(sequence);
                    if (log.isTraceEnabled()) {
                        trace.append(" B");
                    }
                }
            } // end of loop over returnedList
        }
        if (lastPar != null) {
            if (lastPar.endSequence() != null) {
                knuthParagraphs.add(lastPar);
            }
            ElementListObserver.observe(lastPar, "line", fobj.getId());
            if (log.isTraceEnabled()) {
                trace.append(" ]");
            }
        }
        log.trace(trace);
    }
    
    /**
     * Phase 2 of Knuth algorithm: find optimal break points.
     * @param bpdAlignment alignment in BP direction of the paragraph
     * @param context the layout context
     * @return a list of Knuth elements representing broken lines
     */
    public LinkedList createLineBreaks(KnuthParagraph par) {

        LineLayoutPossibilities llPoss;
        LineBreakingAlgorithm alg = 
            new LineBreakingAlgorithm(context.getBPAlignment(), iLineWidth, par);
        llPoss = alg.findOptimalBreakingPoints();
        par.setLlPoss(llPoss);

        //Post-process the line breaks found
        return postProcessLineBreaks(par);
    }

    /**
     * Creates the element list in BP direction for the broken lines.
     * @param bpdAlignment the currently applicable vertical alignment
     * @param context the layout context
     * @return the newly built element list
     */
    private LinkedList postProcessLineBreaks(KnuthParagraph par) {

        LinkedList returnList = new LinkedList();

        int parIndex = knuthParagraphs.indexOf(par);
        if (par.isInlineSequence() && context.getBPAlignment() == EN_JUSTIFY) {
            /* justified vertical alignment (not in the XSL FO recommendation):
                   create a multi-layout sequence whose elements will contain 
                   a conventional Position */
            Position returnPosition = new LeafPosition(this, parIndex);
            createClosingElements(returnList, par.getLlPoss(), returnPosition);
        } else {
            /* "normal" vertical alignment: create a sequence whose boxes
                   represent effective lines, and contain LineBreakPositions */
            LineLayoutPossibilities llPoss = par.getLlPoss();
            Position returnPosition = new LeafPosition(this, parIndex);
            int startIndex = 0;
            for (int i = 0;
            i < llPoss.getChosenLineCount();
            i++) {
                if (!((BlockLevelLayoutManager) parentLM).mustKeepTogether()
                        && i >= fobj.getOrphans()
                        && i <= llPoss.getChosenLineCount() - fobj.getWidows()
                        && returnList.size() > 0) {
                    // null penalty allowing a page break between lines
                    returnList.add(new BreakElement(returnPosition, 0, context));
                    //returnList.add(new KnuthPenalty(0, 0, false, returnPosition, false));
                }
                int endIndex
                = ((LineBreakPosition) llPoss.getChosenPosition(i)).getLeafPos();
                // create a list of the FootnoteBodyLM handling footnotes 
                // whose citations are in this line
                LinkedList footnoteList = new LinkedList();
                ListIterator elementIterator = par.listIterator(startIndex);
                while (elementIterator.nextIndex() <= endIndex) {
                    KnuthElement element = (KnuthElement) elementIterator.next();
                    if (element instanceof KnuthInlineBox
                            && ((KnuthInlineBox) element).isAnchor()) {
                        footnoteList.add(((KnuthInlineBox) element).getFootnoteBodyLM());
                    } else if (element instanceof KnuthBlockBox) {
                        footnoteList.addAll(((KnuthBlockBox) element).getFootnoteBodyLMs());
                    }
                }
                startIndex = endIndex + 1;
                LineBreakPosition lbp = 
                    (LineBreakPosition) llPoss.getChosenPosition(i);
                returnList.add(new KnuthBlockBox
                               (lbp.lineHeight + lbp.spaceBefore + lbp.spaceAfter,
                                footnoteList, lbp, false));
            }
        }

        return returnList;
    }

    /**
     * Create and add the final elements to the existing list of elements
     * Used in justified vertical alignment (not in the XSL FO recommendation)
     * @param list
     * @param llPoss
     * @param elementPosition
     */
    private void createClosingElements(List list, LineLayoutPossibilities llPoss,
                                Position elementPosition) {
        /* number of normal, inner lines */
        int nInnerLines = 0;
        /* number of lines that can be used in order to fill more space */
        int nOptionalLines = 0;
        /* number of lines that can be used in order to fill more space
           only if the paragraph is not parted */
        int nConditionalOptionalLines = 0;
        /* number of lines that can be omitted in order to fill less space */
        int nEliminableLines = 0;
        /* number of lines that can be omitted in order to fill less space
           only if the paragraph is not parted */
        int nConditionalEliminableLines = 0;
        /* number of the first inseparable lines */
        int nFirstLines = fobj.getOrphans();
        /* number of the last inseparable lines */
        int nLastLines = fobj.getWidows();
        /* total number of inseparable lines */
        int nInseparableLines = nFirstLines + nLastLines;
        /* sub-sequence used to separate the elements representing different lines */
        List breaker = new LinkedList();

        {
            /* comment out the next lines in order to test particular situations */
            int nMinLineCount = llPoss.getMinLineCount();
            int nOptLineCount = llPoss.getOptLineCount();
            int nMaxLineCount = llPoss.getMaxLineCount();
            if (nInseparableLines <= nMinLineCount) {
                nInnerLines = nMinLineCount - nInseparableLines;
                nOptionalLines = nMaxLineCount - nOptLineCount;
                nEliminableLines = nOptLineCount - nMinLineCount;
            } else if (nInseparableLines <= nOptLineCount) {
                nOptionalLines = nMaxLineCount - nOptLineCount;
                nEliminableLines = nOptLineCount - nInseparableLines;
                nConditionalEliminableLines = nInseparableLines - nMinLineCount;
            } else if (nInseparableLines <= nMaxLineCount) {
                nOptionalLines = nMaxLineCount - nInseparableLines;
                nConditionalOptionalLines = nInseparableLines - nOptLineCount;
                nConditionalEliminableLines = nOptLineCount - nMinLineCount;
                nFirstLines -= nConditionalOptionalLines;
            } else {
                nConditionalOptionalLines = nMaxLineCount - nOptLineCount;
                nConditionalEliminableLines = nOptLineCount - nMinLineCount;
                nFirstLines = nOptLineCount;
                nLastLines = 0;
            }
            /* comment out the previous lines in order to test particular situations */
        }
        
        /* use these lines to test particular situations
        nInnerLines = 0;
        nOptionalLines = 1;
        nConditionalOptionalLines = 2;
        nEliminableLines = 0;
        nConditionalEliminableLines = 0;
        nFirstLines = 1;
        nLastLines = 3;
        */

        if (nLastLines != 0
            && (nConditionalOptionalLines > 0 || nConditionalEliminableLines > 0)) {
            breaker.add(new KnuthPenalty(0, KnuthElement.INFINITE, false, elementPosition, false));
            breaker.add(new KnuthGlue(0, -nConditionalOptionalLines * constantLineHeight,
                                        -nConditionalEliminableLines * constantLineHeight,
                                        LINE_NUMBER_ADJUSTMENT, elementPosition, false));
            breaker.add(new KnuthPenalty(nConditionalOptionalLines * constantLineHeight,
                                           0, false, elementPosition, false));
            breaker.add(new KnuthGlue(0, nConditionalOptionalLines * constantLineHeight,
                                        nConditionalEliminableLines * constantLineHeight,
                                        LINE_NUMBER_ADJUSTMENT, elementPosition, false));
        } else if (nLastLines != 0) {
            breaker.add(new KnuthPenalty(0, 0, false, elementPosition, false));
        }

        //log.debug("first=" + nFirstLines + " inner=" + nInnerLines
        //                   + " optional=" + nOptionalLines + " eliminable=" + nEliminableLines
        //                   + " last=" + nLastLines
        //                   + " (condOpt=" + nConditionalOptionalLines + " condEl=" + nConditionalEliminableLines + ")");

        // creation of the elements:
        // first group of lines
        list.add(new KnuthBox(nFirstLines * constantLineHeight, elementPosition,
                              (nLastLines == 0
                               && nConditionalOptionalLines == 0
                               && nConditionalEliminableLines == 0 ? true : false)));
        if (nConditionalOptionalLines > 0
            || nConditionalEliminableLines > 0) {
            list.add(new KnuthPenalty(0, KnuthElement.INFINITE, false, elementPosition, false));
            list.add(new KnuthGlue(0, nConditionalOptionalLines * constantLineHeight,
                                   nConditionalEliminableLines * constantLineHeight,
                                   LINE_NUMBER_ADJUSTMENT, elementPosition, false));
            list.add(new KnuthBox(0, elementPosition,
                                  (nLastLines == 0 ? true : false)));
        }

        // optional lines
        for (int i = 0; i < nOptionalLines; i++) {
            list.addAll(breaker);
            list.add(new KnuthBox(0, elementPosition, false));
            list.add(new KnuthPenalty(0, KnuthElement.INFINITE, false, elementPosition, false));
            list.add(new KnuthGlue(0, 1 * constantLineHeight, 0,
                                   LINE_NUMBER_ADJUSTMENT, elementPosition, false));
            list.add(new KnuthBox(0, elementPosition, false));
        }

        // eliminable lines
        for (int i = 0; i < nEliminableLines; i++) {
            list.addAll(breaker);
            list.add(new KnuthBox(1 * constantLineHeight, elementPosition, false));
            list.add(new KnuthPenalty(0, KnuthElement.INFINITE, false, elementPosition, false));
            list.add(new KnuthGlue(0, 0, 1 * constantLineHeight,
                                   LINE_NUMBER_ADJUSTMENT, elementPosition, false));
            list.add(new KnuthBox(0, elementPosition, false));
        }

        // inner lines
        for (int i = 0; i < nInnerLines; i++) {
            list.addAll(breaker);
            list.add(new KnuthBox(1 * constantLineHeight, elementPosition, false));
        }

        // last group of lines
        if (nLastLines > 0) {
            list.addAll(breaker);
            list.add(new KnuthBox(nLastLines * constantLineHeight,
                                  elementPosition, true));
        }
    }

    /**
     * {@inheritDoc}
     */
    public boolean mustKeepTogether() {
        return ((BlockLevelLayoutManager) getParent()).mustKeepTogether();
    }

    /**
     * {@inheritDoc}
     */
    public boolean mustKeepWithPrevious() {
        return false;
    }

    /**
     * {@inheritDoc}
     */
    public boolean mustKeepWithNext() {
        return false;
    }

    /**
     * {@inheritDoc} 
     */
    public int negotiateBPDAdjustment(int adj, KnuthElement lastElement) {
        LeafPosition pos = (LeafPosition)lastElement.getPosition();
        int totalAdj = adj;
        //if (lastElement.isPenalty()) {
        //    totalAdj += lastElement.getW();
        //}
        //int lineNumberDifference = (int)((double) totalAdj / constantLineHeight);
        int lineNumberDifference = (int) Math.round((double) totalAdj / constantLineHeight
                                                    + (adj > 0 ? - 0.4 : 0.4));
        //log.debug("   LLM> variazione calcolata = " + ((double) totalAdj / constantLineHeight) + " variazione applicata = " + lineNumberDifference);
        LineLayoutPossibilities llPoss;
        llPoss = ((KnuthParagraph) knuthParagraphs.get(pos.getLeafPos())).getLlPoss();
        lineNumberDifference = llPoss.applyLineCountAdjustment(lineNumberDifference);
        return lineNumberDifference * constantLineHeight;
    }

    /**
     * {@inheritDoc}
     */
    public void discardSpace(KnuthGlue spaceGlue) {
    }

    /**
     * {@inheritDoc} 
     */
    public LinkedList getChangedKnuthElements(List oldList, int alignment) {
        LinkedList returnList = new LinkedList();
        for (int p = 0; p < knuthParagraphs.size(); p++) {
            LineLayoutPossibilities llPoss;
            llPoss = ((KnuthParagraph) knuthParagraphs.get(p)).getLlPoss();
            //log.debug("demerits of the chosen layout: " + llPoss.getChosenDemerits());
            for (int i = 0; i < llPoss.getChosenLineCount(); i++) {
                if (!((BlockLevelLayoutManager) parentLM).mustKeepTogether()
                    && i >= fobj.getOrphans()
                    && i <= llPoss.getChosenLineCount() - fobj.getWidows()) {
                    // null penalty allowing a page break between lines
                    returnList.add(new KnuthPenalty(0, 0, false, new Position(this), false));
                }
                LineBreakPosition lbp = (LineBreakPosition) llPoss.getChosenPosition(i);
                //log.debug("LLM.getChangedKnuthElements> lineWidth= " + lbp.lineWidth + " difference= " + lbp.difference);
                //log.debug("                             shrink= " + lbp.availableShrink + " stretch= " + lbp.availableStretch);

                //log.debug("linewidth= " + lbp.lineWidth + " difference= " + lbp.difference + " indent= " + lbp.startIndent);
                MinOptMax contentIPD;
                if (alignment == EN_JUSTIFY) {
                    contentIPD = new MinOptMax(
                        lbp.lineWidth - lbp.difference - lbp.availableShrink, 
                        lbp.lineWidth - lbp.difference, 
                        lbp.lineWidth - lbp.difference + lbp.availableStretch);
                } else if (alignment == EN_CENTER) {
                    contentIPD = new MinOptMax(lbp.lineWidth - 2 * lbp.startIndent);
                } else if (alignment == EN_END) {
                    contentIPD = new MinOptMax(lbp.lineWidth - lbp.startIndent);
                } else {
                    contentIPD = new MinOptMax(lbp.lineWidth - lbp.difference + lbp.startIndent);
                }
                returnList.add(new KnuthBlockBox(lbp.lineHeight,
                                                 contentIPD,
                                                 (lbp.ipdAdjust != 0
                                                         ? lbp.lineWidth - lbp.difference : 0),
                                                 lbp, false));
            }
        }
        return returnList;
    }

    /**
     * find hyphenation points for every word int the current paragraph
     * @ param currPar the paragraph whose words will be hyphenated
     */
    public void findHyphenationPoints(KnuthParagraph currPar) {
        // hyphenate every word
        ListIterator currParIterator
            = currPar.listIterator(currPar.getIgnoreAtStart());
        // list of TLM involved in hyphenation
        LinkedList updateList = new LinkedList();
        KnuthElement firstElement = null;
        KnuthElement nextElement = null;
        // current InlineLevelLayoutManager
        InlineLevelLayoutManager currLM = null;
        // number of KnuthBox elements containing word fragments
        int boxCount;
        // number of auxiliary KnuthElements between KnuthBoxes
        int auxCount;
        StringBuffer sbChars = null;

        // find all hyphenation points
        while (currParIterator.hasNext()) {
            firstElement = (KnuthElement) currParIterator.next();
            // 
            if (firstElement.getLayoutManager() != currLM) {
                currLM = (InlineLevelLayoutManager) firstElement.getLayoutManager();
                if (currLM != null) { 
                    updateList.add(new Update(currLM, currParIterator.previousIndex()));
                } else {
                    break;
                }
            } else if (currLM == null) {
                break;
            }
            //TODO Something's not right here. See block_hyphenation_linefeed_preserve.xml
            
            // collect word fragments, ignoring auxiliary elements;
            // each word fragment was created by a different TextLM
            if (firstElement.isBox() && !firstElement.isAuxiliary()) {
                boxCount = 1;
                auxCount = 0;
                sbChars = new StringBuffer();
                currLM.getWordChars(sbChars, firstElement.getPosition());
                // look if next elements are boxes too
                while (currParIterator.hasNext()) {
                    nextElement = (KnuthElement) currParIterator.next();
                    if (nextElement.isBox() && !nextElement.isAuxiliary()) {
                        // a non-auxiliary KnuthBox: append word chars
                        if (currLM != nextElement.getLayoutManager()) {
                            currLM = (InlineLevelLayoutManager) nextElement.getLayoutManager();
                            updateList.add(new Update(currLM, currParIterator.previousIndex()));
                        }
                        // append text to recreate the whole word
                        boxCount++;
                        currLM.getWordChars(sbChars, nextElement.getPosition());
                    } else if (!nextElement.isAuxiliary()) {
                        // a non-auxiliary non-box KnuthElement: stop
                        // go back to the last box or auxiliary element
                        currParIterator.previous(); 
                        break;
                    } else {
                        if (currLM != nextElement.getLayoutManager()) {
                            currLM = (InlineLevelLayoutManager) nextElement.getLayoutManager();
                            updateList.add(new Update(currLM, currParIterator.previousIndex()));
                        }
                        // an auxiliary KnuthElement: simply ignore it
                        auxCount++;
                    }
                }
                log.trace(" Word to hyphenate: " + sbChars.toString());
                // find hyphenation points
                HyphContext hc = getHyphenContext(sbChars);
                // ask each LM to hyphenate its word fragment
                if (hc != null) {
                    KnuthElement element = null;
                    for (int i = 0; i < (boxCount + auxCount); i++) {
                        currParIterator.previous();
                    }
                    for (int i = 0; i < (boxCount + auxCount); i++) {
                        element = (KnuthElement) currParIterator.next();
                        if (element.isBox() && !element.isAuxiliary()) {
                            ((InlineLevelLayoutManager)
                             element.getLayoutManager()).hyphenate(element.getPosition(), hc);
                        } else {
                            // nothing to do, element is an auxiliary KnuthElement
                        }
                    }
                }
            }
        }

        // create iterator for the updateList
        ListIterator updateListIterator = updateList.listIterator();
        Update currUpdate = null;
        //int iPreservedElements = 0;
        int iAddedElements = 0;
        //int iRemovedElements = 0;

        while (updateListIterator.hasNext()) {
            // ask the LMs to apply the changes and return 
            // the new KnuthElements to replace the old ones
            currUpdate = (Update) updateListIterator.next();
            int fromIndex = currUpdate.iFirstIndex;
            int toIndex;
            if (updateListIterator.hasNext()) {
                Update nextUpdate = (Update) updateListIterator.next();
                toIndex = nextUpdate.iFirstIndex;
                updateListIterator.previous();
            } else {
                // maybe this is not always correct!
                toIndex = currPar.size() - currPar.getIgnoreAtEnd()
                    - iAddedElements;
            }

            // applyChanges() returns true if the LM modifies its data,
            // so it must return new KnuthElements to replace the old ones
            if ((currUpdate.inlineLM)
                .applyChanges(currPar.subList(fromIndex + iAddedElements,
                                              toIndex + iAddedElements))) {
                // insert the new KnuthElements
                LinkedList newElements = null;
                newElements
                    = currUpdate.inlineLM.getChangedKnuthElements
                    (currPar.subList(fromIndex + iAddedElements,
                                     toIndex + iAddedElements),
                     /*flaggedPenalty,*/ effectiveAlignment);
                // remove the old elements
                currPar.subList(fromIndex + iAddedElements,
                                toIndex + iAddedElements).clear();
                // insert the new elements
                currPar.addAll(fromIndex + iAddedElements, newElements);
                iAddedElements += newElements.size() - (toIndex - fromIndex);
            }
        }
        updateListIterator = null;
        updateList.clear();
    }

    /**
     * Line area is always considered to act as a fence.
     * @param isNotFirst ignored
     * @return always true
     */
    protected boolean hasLeadingFence(boolean isNotFirst) {
        return true;
    }

    /**
     * Line area is always considered to act as a fence.
     * @param isNotLast ignored
     * @return always true
     */
    protected boolean hasTrailingFence(boolean isNotLast) {
        return true;
    }

    private HyphContext getHyphenContext(StringBuffer sbChars) {
        // Find all hyphenation points in this word
        // (get in an array of offsets)
        // hyphenationProperties are from the block level?.
        // Note that according to the spec,
        // they also "apply to" fo:character.
        // I don't know what that means, since
        // if we change language in the middle of a "word",
        // the effect would seem quite strange!
        // Or perhaps in that case, we say that it's several words.
        // We probably should bring the hyphenation props up from the actual
        // TextLM which generate the hyphenation buffer,
        // since these properties inherit and could be specified
        // on an inline or wrapper below the block level.
        Hyphenation hyph
            = Hyphenator.hyphenate(hyphenationProperties.language.getString(),
                               hyphenationProperties.country.getString(),
                               getFObj().getUserAgent().getFactory().getHyphenationTreeResolver(),
                               sbChars.toString(),
                               hyphenationProperties.hyphenationRemainCharacterCount.getValue(),
                               hyphenationProperties.hyphenationPushCharacterCount.getValue());
        // They hyph structure contains the information we need
        // Now start from prev: reset to that position, ask that LM to get
        // a Position for the first hyphenation offset. If the offset isn't in
        // its characters, it returns null,
        // but must tell how many chars it had.
        // Keep looking at currentBP using next hyphenation point until the
        // returned size is greater than the available size
        // or no more hyphenation points remain. Choose the best break.
        if (hyph != null) {
            return new HyphContext(hyph.getHyphenationPoints());
        } else {
            return null;
        }
    }

    /**
     * Add the areas with the break points.
     *
     * @param parentIter the iterator of break positions
     * @param context the context for adding areas
     */
    public void addAreas(PositionIterator parentIter,
                         LayoutContext context) {
        while (parentIter.hasNext()) {
            Position pos = (Position) parentIter.next();
            boolean isLastPosition = !parentIter.hasNext();
            if (pos instanceof LineBreakPosition) {
                addInlineArea(context, pos, isLastPosition);
            } else if ((pos instanceof NonLeafPosition) && pos.generatesAreas()) {
                addBlockArea(context, pos, isLastPosition);
            } else {
                /*                
                 * pos was the Position inside a penalty item, nothing to do;
                 * or Pos does not generate an area,
                 * i.e. it stand for spaces, borders and padding.
                 */            
            }
        }
        setCurrentArea(null); // ?? necessary
    }

    /**
     * Add a line with inline content
     * @param context the context for adding areas
     * @param pos the position for which the line is generated
     * @param isLastPosition true if this is the last position of this LM
     */
    private void addInlineArea(LayoutContext context, Position pos, boolean isLastPosition) {
            ListIterator seqIterator = null;
            KnuthElement tempElement = null;
            // the TLM which created the last KnuthElement in this line
            LayoutManager lastLM = null;
            
            LineBreakPosition lbp = (LineBreakPosition) pos;
            int iCurrParIndex;
            iCurrParIndex = lbp.iParIndex;
            KnuthSequence seq = (KnuthSequence) knuthParagraphs.get(iCurrParIndex);
            int iStartElement = lbp.iStartIndex;
            int iEndElement = lbp.getLeafPos();
            
            LineArea lineArea
              = new LineArea((lbp.getLeafPos() < seq.size() - 1
                              ? textAlignment : textAlignmentLast),
                              lbp.difference, lbp.availableStretch, lbp.availableShrink);
            if (lbp.startIndent != 0) {
                lineArea.addTrait(Trait.START_INDENT, new Integer(lbp.startIndent));
            }
            lineArea.setBPD(lbp.lineHeight);
            lineArea.setIPD(lbp.lineWidth);
            lineArea.addTrait(Trait.SPACE_BEFORE, new Integer(lbp.spaceBefore));
            lineArea.addTrait(Trait.SPACE_AFTER, new Integer(lbp.spaceAfter));
            alignmentContext.resizeLine(lbp.lineHeight, lbp.baseline);
            
            if (seq instanceof KnuthParagraph) {
                KnuthParagraph currPar = (KnuthParagraph) seq;
                // ignore the first elements added by the LineLayoutManager
                iStartElement += (iStartElement == 0) ? currPar.getIgnoreAtStart() : 0;
                
                // if this is the last line area that for this paragraph,
                // ignore the last elements added by the LineLayoutManager and
                // subtract the last-line-end-indent from the area ipd
                if (iEndElement == (currPar.size() - 1)) {
                    iEndElement -= currPar.getIgnoreAtEnd();
                    lineArea.setIPD(lineArea.getIPD() - lastLineEndIndent.getValue(this));
                }
            }
            
            // Remove trailing spaces if allowed so
            if (whiteSpaceTreament == EN_IGNORE_IF_SURROUNDING_LINEFEED
                || whiteSpaceTreament == EN_IGNORE 
                || whiteSpaceTreament == EN_IGNORE_IF_BEFORE_LINEFEED) {
                // ignore the last element in the line if it is a KnuthGlue object
                seqIterator = seq.listIterator(iEndElement);
                tempElement = (KnuthElement) seqIterator.next();
                if (tempElement.isGlue()) {
                    iEndElement--;
                    // this returns the same KnuthElement
                    seqIterator.previous();
                    if (seqIterator.hasPrevious()) {
                        tempElement = (KnuthElement) seqIterator.previous();
                    } else {
                        tempElement = null;
                    }
                }
                if (tempElement != null) {
                    lastLM = tempElement.getLayoutManager();
                }
            }
            
            // Remove leading spaces if allowed so
            if (whiteSpaceTreament == EN_IGNORE_IF_SURROUNDING_LINEFEED
                || whiteSpaceTreament == EN_IGNORE 
                || whiteSpaceTreament == EN_IGNORE_IF_AFTER_LINEFEED) {
                // ignore KnuthGlue and KnuthPenalty objects
                // at the beginning of the line
                seqIterator = seq.listIterator(iStartElement);
                tempElement = (KnuthElement) seqIterator.next();
                while (!tempElement.isBox() && seqIterator.hasNext()) {
                    tempElement = (KnuthElement) seqIterator.next();
                    iStartElement++;
                }
            }
            // Add the inline areas to lineArea
            PositionIterator inlinePosIter
              = new KnuthPossPosIter(seq, iStartElement, iEndElement + 1);
            
            iStartElement = lbp.getLeafPos() + 1;
            if (iStartElement == seq.size()) {
                // advance to next paragraph
                iStartElement = 0;
            }
            
            LayoutContext lc = new LayoutContext(0);
            lc.setAlignmentContext(alignmentContext);
            lc.setSpaceAdjust(lbp.dAdjust);
            lc.setIPDAdjust(lbp.ipdAdjust);
            lc.setLeadingSpace(new SpaceSpecifier(true));
            lc.setTrailingSpace(new SpaceSpecifier(false));
            lc.setFlags(LayoutContext.RESOLVE_LEADING_SPACE, true);
            
            /*
             * extension (not in the XSL FO recommendation): if the left and right margins
             * have been optimized, recompute indents and / or adjust ratio, according
             * to the paragraph horizontal alignment
             */
            if (false && textAlignment == EN_JUSTIFY) {
                // re-compute space adjust ratio
                int updatedDifference = context.getStackLimit().opt
                                        - lbp.lineWidth + lbp.difference;
                double updatedRatio = 0.0;
                if (updatedDifference > 0) {
                    updatedRatio = (float) updatedDifference / lbp.availableStretch;
                } else if (updatedDifference < 0) {
                    updatedRatio = (float) updatedDifference / lbp.availableShrink;
                }
                lc.setIPDAdjust(updatedRatio);
                //log.debug("LLM.addAreas> old difference = " + lbp.difference + " new difference = " + updatedDifference);
                //log.debug("              old ratio = " + lbp.ipdAdjust + " new ratio = " + updatedRatio);
            } else if (false && textAlignment == EN_CENTER) {
                // re-compute indent
                int updatedIndent = lbp.startIndent
                                    + (context.getStackLimit().opt - lbp.lineWidth) / 2;
                lineArea.addTrait(Trait.START_INDENT, new Integer(updatedIndent));
            } else if (false && textAlignment == EN_END) {
                // re-compute indent
                int updatedIndent = lbp.startIndent 
                                    + (context.getStackLimit().opt - lbp.lineWidth);
                lineArea.addTrait(Trait.START_INDENT, new Integer(updatedIndent));
            }
            
            setCurrentArea(lineArea);
            setChildContext(lc);
            LayoutManager childLM;
            while ((childLM = inlinePosIter.getNextChildLM()) != null) {
                lc.setFlags(LayoutContext.LAST_AREA, (childLM == lastLM));
                childLM.addAreas(inlinePosIter, lc);
                lc.setLeadingSpace(lc.getTrailingSpace());
                lc.setTrailingSpace(new SpaceSpecifier(false));
            }
            
            // when can this be null?
            // if display-align is distribute, add space after 
            if (context.getSpaceAfter() > 0
                    && (!context.isLastArea() || !isLastPosition)) {
                lineArea.setBPD(lineArea.getBPD() + context.getSpaceAfter());
            }
            lineArea.finalise();
            parentLM.addChildArea(lineArea);
    }
    
    /**
     * Add a line with block content
     * @param context the context for adding areas
     * @param pos the position for which the line is generated
     * @param isLastPosition true if this is the last position of this LM
     */
    private void addBlockArea(LayoutContext context, Position pos, boolean isLastPosition) {
        /* Nested block-level content;
         * go down the LM stack again;
         * "unwrap" the positions and put the child positions in a new list.
         * The positionList must contain one area-generating position,
         * which creates one line area.
         */
        List positionList = new ArrayList(1);
        Position innerPosition;
        innerPosition = ((NonLeafPosition) pos).getPosition();
        positionList.add(innerPosition);

        // do we have the last LM?
        LayoutManager lastLM = null;
        if (isLastPosition) {
            lastLM = innerPosition.getLM();
        }
        
        LineArea lineArea = new LineArea();
        setCurrentArea(lineArea);
        LayoutContext lc = new LayoutContext(0);
        lc.setAlignmentContext(alignmentContext);
        setChildContext(lc);
        
        PositionIterator childPosIter = new StackingIter(positionList.listIterator());
        LayoutContext blocklc = new LayoutContext(0);
        blocklc.setLeadingSpace(new SpaceSpecifier(true));
        blocklc.setTrailingSpace(new SpaceSpecifier(false));
        blocklc.setFlags(LayoutContext.RESOLVE_LEADING_SPACE, true);
        LayoutManager childLM;
        while ((childLM = childPosIter.getNextChildLM()) != null) {
            // set last area flag
            blocklc.setFlags(LayoutContext.LAST_AREA,
                             (context.isLastArea() && childLM == lastLM));
            blocklc.setStackLimit(context.getStackLimit());
            // Add the line areas to Area
            childLM.addAreas(childPosIter, blocklc);
            blocklc.setLeadingSpace(blocklc.getTrailingSpace());
            blocklc.setTrailingSpace(new SpaceSpecifier(false));
        }
        lineArea.updateExtentsFromChildren();
        parentLM.addChildArea(lineArea);
    }

    /**
     * {@inheritDoc}
     */
    public void addChildArea(Area childArea) {
        // Make sure childArea is inline area
        if (childArea instanceof InlineArea) {
            Area parent = getCurrentArea();
            if (getContext().resolveLeadingSpace()) {
                addSpace(parent,
                         getContext().getLeadingSpace().resolve(false),
                         getContext().getSpaceAdjust());
            }
            parent.addChildArea(childArea);
        }
    }

    // --------- Property Resolution related functions --------- //
    
    /**
     * {@inheritDoc}
     */
    public boolean getGeneratesBlockArea() {
        return true;
    }
   
    /**
     * {@inheritDoc}
     */
    public boolean getGeneratesLineArea() {
        return true;
    }
}


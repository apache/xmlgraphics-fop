<?xml version="1.0" standalone="no"?>

<!-- by Arved Sandstrom -->

<s1 title="FOP Mechanics">

<s2 title="Introduction">

<p>
The overall process is controlled by <em>org.apache.fop.apps.Driver</em>. In
this class, a typical sequence is:</p>

<source>Driver driver = new Driver();<br/>
driver.setRenderer("org.apache.fop.render.pdf.PDFRenderer", version);<br/>
driver.setOutputStream(new FileOutputStream(args[1]));<br/>
driver.render(parser, inputHandler.getInputSource());</source>
</s2>

<s2 title="Formatting Object Tree">
<p>The class <em>org.apache.fop.fo.FOTreeBuilder</em> is responsible for actually
constructing the FO tree. The key SAX events used are </p>
<p><code>startElement()</code>,</p>
<p><code>endElement()</code> and <code>characters()</code>.</p>

<p>All formatting objects derive from abstract class
<em>org.apache.fop.fo.FONode</em>. The other FO classes inherit from 
<em>FONode</em> as follows:</p>

<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FONode</code></p>
<p><code>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</code></p>
<p><code>&#160;&#160;&#160;&#160;&#160;__________|________</code></p>
<p><code>&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</code></p>
<p><code>&#160;&#160;&#160;FObj&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;FOText</code></p>
<p><code>&#160;&#160;&#160;&#160;|</code></p>
<p><code>&#160;&#160;&#160;&#160;|___________________</code></p>
<p><code>&#160;&#160;&#160;&#160;|&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;|</code></p>
<p><code>&#160;&#160;FObjMixed&#160;&#160;&#160;&#160;&#160;&#160;SequenceSpecifier
</code></p>

<p>FO's extending FObj:</p>

<p>Package org.apache.fop.fo.pagination:</p>


<p><code>       LayoutMasterSet</code></p>
<p><code>       PageSequence</code></p>
<p><code>       RegionAfter</code></p>
<p><code>       RegionBefore</code></p>
<p><code>       RegionBody</code></p>
<p><code>       Root</code></p>
<p><code>       SequenceSpecification</code></p>
<p><code>       SimplePageMaster</code></p>


   <p>Package org.apache.fop.fo.flow:</p>


<p><code>BlockContainer</code></p>
<p><code>DisplayGraphic</code></p>
<p><code>DisplayRule</code></p>
<p><code>DisplaySequence</code></p>
<p><code>Flow</code></p>
<p><code>InlineGraphic</code></p>
<p><code>ListBlock</code></p>
<p><code>ListItem</code></p>
<p><code>ListItemBody</code></p>
<p><code>ListItemLabel</code></p>
<p><code>PageNumber</code></p>
<p><code>StaticContent</code></p>
<p><code>Table</code></p>
<p><code>TableBody</code></p>
<p><code>TableCell</code></p>
<p><code>TableColumn</code></p>
<p><code>TableRow</code></p>

<p>FO's extending SequenceSpecifier:</p>

   <p>Package org.apache.fop.fo.pagination:</p>


<p><code>SequenceSpecifierAlternating</code></p>
<p><code>SequenceSpecifierRepeating</code></p>
<p><code>SequenceSpecifierSingle</code></p>

<p>FO's extending FObjMixed:</p>

   <p>Package org.apache.fop.fo.flow:</p>


<p><code>Block</code></p>
<p><code>Inline</code></p>
<p><code>BasicLink</code></p>

</s2>

<s2 title="FONode">
<p>
The class inheritance described above only describes the nature of the
content. Every FO in FOP also has a parent, and a Vector of children. The
parent attribute (in the Java sense), in particular, is used to enforce
constraints required by the FO hierarchy.
</p>

<p>
FONode, among other things, ensures that FO's have a parent, that they
have children, that they maintain a marker of where the layout was up to
(for FObj's it is the child number, and for FOText's it is the character
number), and that they have a <code>layout()</code> method.
</p>
</s2>

<s2 title="Making FO's">

<p>
Every FO class has code that looks something like this:
</p>

<p><code>public static class Maker extends FObj.Maker {</code></p>
<p><code>&#160;&#160;  public FObj make(FObj parent, PropertyList propertyList)</code></p>
<p><code>&#160;&#160;&#160;&#160;    throws FOPException</code></p>
<p><code>&#160;&#160;  {</code></p>
<p><code>&#160;&#160;&#160;&#160;    return new SimplePageMaster(parent, propertyList);</code></p>
<p><code>&#160;&#160;  }</code></p>
<p><code>}</code></p>


<p>
The class also has a static method that resembles
</p>

<p><code>public static FObj.Maker maker()</code></p>
<p><code>&#160;&#160; {</code></p>
<p><code>&#160;&#160;&#160;&#160;     return new PageSequence.Maker();</code></p>
<p><code>&#160;&#160;   }</code></p>

<p>
A hash 'fobjTable' exists in <em>FOTreeBuilder</em>, and maps the FO names (such as
'fo:table') to object references to the appropriate factories
(such as <em>Table.Maker</em>).
</p>

<p>
Properties (recall that FO's have properties, areas have traits, and XML
nodes have attributes) are also a concern of <em>FOTreeBuilder</em>. It
accomplishes this by using a <em>PropertyListBuilder</em>. There is a
separate <em>PropertyListBuilder</em> for each namespace encountered
while building the FO tree. Each Builder object contains a hash of
property names and <ref>their</ref> respective makers. It may also
contain element-specific property maker hashes; these are based on the
<em>local name</em> of the flow object, ie. <em>table-row</em>, not
<em>fo:table-row</em>. If an element-specific property mapping exists,
it is preferred to the generic mapping.</p>
<p>The base class for all
properties is <em>Property</em>, and all the property makers extend
<em>Property.Maker</em>. A more complete discussion of the property
architecture may be found in <jump href="properties.html">Properties</jump>.
</p>
</s2>
<s2 title="FO Formatting">

<p>
<em>FOTreeBuilder</em> calls <code>format()</code> on the root FO, passing 
it the <em>AreaTree</em>
reference. In turn, <em>Root</em> calls <code>format()</code> on each 
<em>PageSequence</em>, passing <ref>it</ref>
the <em>AreaTree</em> reference.
</p>

<p>
The <em>PageSequence</em> <code>format()</code> method does the following things:
</p>

<ol>
<li>Makes a <em>Page</em>, using <em>PageMasterFactory</em> to produce a 
<em>PageMaster</em>, and
using <code>makePage()</code> in the latter class. In the simplest picture, 
a <em>Page</em> has
5 areas represented by <em>AreaContainers</em>;</li>

<li>Handles layout for <em>StaticContent</em> objects in the 'before' and 'after'
regions, if set. This uses the <code>layout()</code> method in 
<em>StaticContent</em>;</li>

<li>If a page break is not forced, it will continue to layout the flow into
the body area (<em>AreaContainer</em>) of the current page;</li>

<li>It continues with (1) when layout into the current page is done, but
the flow is not empty.</li>
</ol>
</s2>

<s2 title="Area Layout">

<p>
FO's that represent actual areas, starting with <em>Flow</em> and 
<em>StaticContent</em>, have
a <code>layout()</code> method, with the following signature:
</p>

<p>
<code>
   public Status layout(Area area)
</code>
</p>

<p>
The fundamental role of the <code>layout()</code> method is to manage the layout of
children and/or to generate new areas.
</p>

<p>
<em>Example</em>: the <code>layout()</code> method for <em>Flow</em> generates no new areas - it manages the
layout of the flow children.
</p>

<p>
<em>Example</em>: the <code>layout()</code> method for <em>Block</em> 
generates a new <em>BlockArea</em> in and of
itself, and also manages the layout of the block children, which are added
to the <em>BlockArea</em> before that is itself added to its parent 
<em>Area</em>.
</p>

<p>
<code>Layout()</code> methods are subject to the general constraint that possibly not
all of their children can be accommodated, and they report back accordingly
with an appropriate <em>Status</em>.
</p>
</s2>

<s2 title="Rendering">

<p>
This is a separate process. The <code>render()</code> method in 
<em>Driver</em> is invoked (say,
by <em>CommandLine</em>) with the laid-out <em>AreaTree</em> and a 
<em>PrintWriter</em> as arguments.
This actually calls the <code>render()</code> method in a specific implementation of
the <em>Renderer</em> interface, typically <em>PDFRenderer</em> or 
<em>AWTRenderer</em>.
</p>

<p>
At the highest level <em>PDFRenderer</em>, for example, begins by rendering each
<em>Page</em>. The <code>render()</code> method in <em>Page</em> (as is the case for other areas),
invokes a particular method in the renderer of choice, e.g. 
<code>renderPage()</code>.
<em>NOTE</em>: this system is bypassed for <em>Page</em>, incidentally.
</p>

</s2>


<!-- by Art Welch -->
<s2 title="Renderers">
	<s3 title="PrintRenderer">
		<p>The PrintRenderer is an abstract base class for print type renderers. Currently the PCL, PDF, and TXT renderers extend from this. This allows as much common functionality to be contained in one place as possible (at least as much as I could consolidate fairly quickly). Unfortunately I have not yet been able to make the renderPage and renderWordArea methods common. This is unfortunate because these methods seem to experience the most activity. Maybe soneone else will have a clever solution to this (without breaking them into a bunch of little bits).</p>
		<p>It is my hope that this base class will be useful for other renderers as well.</p>
	</s3>

	<s3 title="PCLRenderer">
		<p>The PCLRenderer is a FOP renderer that should produce output as close to identical as possible to the printed output of the PDFRenderer within the limitations of the renderer, and output device.</p>

		<p>The output created by the PCLRenderer is generic PCL 5 as documented in the "HP PCL 5 Printer Language Technical Reference Manual" (copyright 1990). This should allow any device fully supporting PCL 5 to be able to print the output generated by the PCLRenderer.</p>

		<s4 title="Limitations">
			<ul>
				<li>Text or graphics outside the left or top of the printable area are not rendered properly. In general things that should print to the left of the printable area are shifted to the right so that they start at the left edge of the printable area and an error message is generated.</li>
				<li>The Helvetica and Times fonts are not well supported among PCL printers so Helvetica is mapped to Arial and Times is mapped to Times New. This is done in the PCLRenderer, no changes are required in the FO's. The metrics and appearance for Helvetica/Arial and Times/Times New are nearly identical, so this has not been a problem so far.</li>
				<li>Only the original fonts built into FOP are supported.</li>
				<li>For the non-symbol fonts, the ISO 8859/1 symbol set is used (PCL set "0N").</li>
				<li>Multibyte characters are not supported.</li>
				<li>SVG support is limited. Currently only lines, rectangles (may be rounded), circles, ellipses, text, simple paths, and images are supported. Colors are supported (dithered black and white) but not gradients.</li>
				<li>Images print black and white only (not dithered). When the renderer prints a color image it uses a threshold value, colors above the threshold are printed as white and below are black. If you need to print a non-monochrome image you should dither it first.</li>
				<li>Image scaling is accomplished by modifying the effective resolution of the image data. The available resolutions are 75, 100, 150, 300, and 600 DPI.</li>
				<li>Color printing is not supported. Colors are rendered by mapping the color intensity to one of the PCL fill shades (from white to black in 9 steps).</li>
				<li>SVG clipping is not supported.</li>
			</ul>
		</s4>

		<s4 title="Additional Features">
			<p>There are some special features that are controlled by some public variables on the PCLRenderer class.</p>

			<dl>
				<dt>orientation</dt>
				<dd><p>The logical page orientation is controlled by the public orientation variable. Legal values are:</p>
					<ul>
						<li>0	Portrait</li>
						<li>1	Landscape</li>
						<li>2	Reverse Portrait</li>
						<li>3	Reverse Landscape</li>
					</ul>
				</dd>
				<dt>curdiv, paperheight</dt>
				<dd>The curdiv and paperheight variables allow multiple virtual pages to be printed on a piece of paper. This allows a standard laser printer to use perforated paper where every perforation will represent an individual page. The paperheight sets the height of a piece of paper in decipoints. This will be divided by the page.getHeight() to determine the number of equal sized divisions (pages) that will fit on the paper. The curdiv variable may be read/written to get/set the current division on the page (to set the starting division and read the ending division for multiple invocations).</dd>
				<dt>topmargin, leftmargin</dt>
				<dd>The topmargin and leftmargin may be used to increase the top and left margins for printing.</dd>
			</dl>
		</s4>
	</s3>

	<s3 title="TXTRenderer">
		<p>The TXTRenderer is a FOP renderer that produces plain ASCII text output that attempts to match the output of the PDFRenderer as closely as possible. This was originally developed to accommodate an archive system that could only accept plain text files. Of course when limited to plain fixed pitch text the output does not always look very good.</p>
		<p>The TXTRenderer works with a fixed size page buffer. The size of this buffer is controlled with the textCPI and textLPI public variables. The textCPI is the effective horizontal characters per inch to use. The textLPI is the vertical lines per inch to use. From these values and the page width and height the size of the buffer is calculated. The formatting objects to be rendered are then mapped to this grid. Graphic elements (lines, borders, etc) are assigned a lower priority than text, so text will overwrite any graphic element representations.</p>
	</s3>
</s2>


<s2 title="UML Diagrams">
<p>
You can find UML diagramms for all Fop packages (latest release version) 
<jump href="http://xml.apache.org/dist/fop/fop-uml.zip">here</jump>.</p>
</s2>

<s2 title="SVG">

<p>
FOP supports svg rendering. SVG is supported as an instream-foreign-object
embedded in an FO document or as an external SVG image.
</p>

<p>
If the svg is embedded in an instream-foreign-object then all the elements and
attributes are read directly and converted into an SVG DOM representation
using the Batik library. This is then stored as a DOM until required for rendering.
The rendering process depends on the what type of renderer is being used.
</p>

<p>
The SVG DOM is rendered in the PDF renderer by using the abitlity of Batik to render
DOM to a Graphics2D. First the DOM is converted into an intermediate representation
then this is rendered to a PDFGraphics2D graphic object which writes the drawing
instructions directly as PDF markup.
</p>

<p>
The AWTRenderer and the PrintRenderer use Batik directly to draw the SVG image
into the current java Graphics2D context.
</p>

<p>
For more information see the SVG documentation.
</p>
</s2>
</s1>
